{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IAaveLendingPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract IAaveLendingPool {\n  function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\n    public;\n}\n"
    },
    "contracts/interfaces/IADai.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\n\ncontract IADai is IERC20 {\n  function redeem(uint256 _amount) public;\n  function redirectInterestStream(address _to) public;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is Initializable, Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(_msgSender(), to, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(_msgSender(), spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, _msgSender(), _allowances[from][_msgSender()].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount));\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/upgrades/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they not should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, with should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract ILendingPoolAddressesProvider {\n    function getLendingPool() public view returns (address);\n    function getLendingPoolCore() public view returns (address);\n}\n\n// INSERT LATER INTO NOLOSSDAO\n// Therefore, whenever it's required to access the LendingPool contract\n// it is recommended to fetch the correct address from the LendingPoolAddressesProvider smart contract.\n\n// Just want to get it to compile. coIo'lll suese this terminal ::DD\n// LendingPoolAddressesProvider provider = LendingPoolAddressesProvider(\n//     0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\n// );\n// LendingPool lendingPool = LendingPool(provider.getLendingPool());\n\n"
    },
    "contracts/interfaces/INoLossDao.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract INoLossDao {\n  function noLossDeposit(address userAddress) external returns (bool);\n  function noLossWithdraw(address userAddress) external returns (bool);\n\n  function noLossCreateProposal(\n    string calldata proposalHash,\n    address benefactorAddress\n  ) external returns (uint256 newProposalId);\n\n  function noLossWithdrawProposal(address benefactorAddress)\n    external\n    returns (bool);\n\n}\n"
    },
    "contracts/interfaces/IPoolDeposits.sol": {
      "content": "pragma solidity ^0.5.0;\n\ncontract IPoolDeposits {\n  mapping(address => uint256) public depositedDai;\n\n  function usersDeposit(address userAddress) external view returns (uint256);\n\n  function redirectInterestStreamToWinner(address _winner) external;\n\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity 0.5.15;\n\n\ncontract Migrations {\n  address public owner;\n  uint256 public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint256 completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/mocks/AaveLendingPool.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '../interfaces/IAaveLendingPool.sol';\nimport './MockERC20.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\n\ncontract AaveLendingPool is IAaveLendingPool {\n  MockERC20 public aDai;\n  constructor(MockERC20 aDaiAddress) public {\n    aDai = aDaiAddress;\n  }\n  function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\n    public\n  {\n    // For now, do nothing\n  }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol';\n\ncontract MockERC20 is ERC20, ERC20Mintable, ERC20Burnable, ERC20Detailed {\n  address public steward;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    address minter\n  ) public {\n    ERC20Detailed.initialize(name, symbol, decimals);\n    ERC20Mintable.initialize(minter);\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\n    function initialize(address sender) public initializer {\n        MinterRole.initialize(sender);\n    }\n\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract MinterRole is Initializable, Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\ncontract ERC20Burnable is Initializable, Context, ERC20 {\n    /**\n     * @dev Destoys `amount` tokens from the caller.\n     *\n     * See `ERC20._burn`.\n     */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is Initializable, IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/mocks/ADai.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport '../interfaces/IADai.sol';\nimport './MockERC20.sol';\n// import '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\n\n// MOCK ONLY\ncontract ADai is IADai, MockERC20 {\n  MockERC20 public dai;\n  constructor(MockERC20 daiAddress)\n    public\n    MockERC20('aDai', 'AD', 18, msg.sender)\n  {\n    dai = daiAddress;\n  }\n  function redeem(uint256 _amount) public {\n    dai.mint(msg.sender, _amount);\n  }\n  function redirectInterestStream(address _to) public {}\n}\n"
    },
    "contracts/mocks/LendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\nimport '../interfaces/ILendingPoolAddressesProvider.sol';\nimport './AaveLendingPool.sol';\n\ncontract LendingPoolAddressesProvider is  ILendingPoolAddressesProvider {\n\n    AaveLendingPool public aaveLendingPool;\n    constructor(AaveLendingPool aaveLendingPoolAddress) public {\n        aaveLendingPool = aaveLendingPoolAddress;\n    }\n    function getLendingPool() public view returns (address){\n        return address(aaveLendingPool);\n    }\n    function getLendingPoolCore() public view returns (address){\n        return address(aaveLendingPool);\n    }\n\n}"
    },
    "contracts/NoLossDao_v0.sol": {
      "content": "pragma solidity 0.5.15;\n\n// import \"./interfaces/IERC20.sol\";\nimport './interfaces/IAaveLendingPool.sol';\nimport './interfaces/IADai.sol';\nimport './interfaces/IPoolDeposits.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\nimport '@nomiclabs/buidler/console.sol';\n\n\n/** @title No Loss Dao Contract. */\ncontract NoLossDao_v0 is Initializable {\n  using SafeMath for uint256;\n\n  //////// MASTER //////////////\n  address public admin;\n\n  //////// Iteration specific //////////\n  uint256 public votingInterval;\n  uint256 public proposalIteration;\n\n  ///////// Proposal specific ///////////\n  uint256 public proposalId;\n  uint256 public proposalDeadline; // keeping track of time\n  mapping(uint256 => string) public proposalDetails; // IPFS hash of proposal\n  mapping(address => uint256) public benefactorsProposal; // benefactor -> proposal id\n  mapping(uint256 => address) public proposalOwner; // proposal id -> benefactor (1:1 mapping)\n  enum ProposalState {DoesNotExist, Withdrawn, Active, Cooldown} // Add Cooldown state and pending state\n  mapping(uint256 => ProposalState) public state; // ProposalId to current state\n\n  //////// User specific //////////\n  mapping(address => uint256) public iterationJoined; // Which iteration did user join DAO\n  mapping(uint256 => mapping(address => uint256)) public usersNominatedProject; // iteration -> user -> chosen project\n\n  //////// DAO / VOTE specific //////////\n  mapping(uint256 => mapping(uint256 => uint256)) public proposalVotes; /// iteration -> proposalId -> num votes\n  mapping(uint256 => uint256) public topProject;\n  mapping(address => address) public voteDelegations; // For vote proxy\n\n  ///////// DEFI Contrcats ///////////\n  IPoolDeposits public depositContract;\n\n  // Crrate blank 256 arrays of fixed length for upgradability.\n\n  ///////// Events ///////////\n  event VoteDelegated(address indexed user, address delegatedTo);\n  event VotedDirect(\n    address indexed user,\n    uint256 indexed iteration,\n    uint256 indexed proposalId\n  );\n  event VotedViaProxy(\n    address indexed proxy,\n    address user,\n    uint256 indexed iteration,\n    uint256 indexed proposalId\n  );\n  event IterationChanged(uint256 timeStamp, address miner);\n  event IterationWinner(\n    uint256 indexed propsalIteration,\n    address indexed winner,\n    uint256 indexed projectId\n  );\n\n  ////////////////////////////////////\n  //////// Modifiers /////////////////\n  ////////////////////////////////////\n  modifier onlyAdmin() {\n    require(msg.sender == admin, 'Not admin');\n    _;\n  }\n\n  modifier userStaked(address givenAddress) {\n    require(\n      depositContract.depositedDai(givenAddress) > 0,\n      'User has no stake'\n    );\n    _;\n  }\n\n\n  modifier noVoteYet(address givenAddress) {\n    require(\n      usersNominatedProject[proposalIteration][givenAddress] == 0,\n      'User already voted this iteration'\n    );\n    _;\n  }\n\n  modifier userHasActiveProposal(address givenAddress) {\n    require(\n      state[benefactorsProposal[givenAddress]] == ProposalState.Active,\n      'User proposal does not exist'\n    );\n    _;\n  }\n\n  modifier userHasNoActiveProposal(address givenAddress) {\n    require(\n      state[benefactorsProposal[givenAddress]] != ProposalState.Active,\n      'User has an active proposal'\n    );\n    _;\n  }\n\n  modifier userHasNoProposal(address givenAddress) {\n    require(benefactorsProposal[givenAddress] == 0, 'User has a proposal');\n    _;\n  }\n\n  modifier proposalActive(uint256 propId) {\n    require(state[propId] == ProposalState.Active, 'Proposal is not active');\n    _;\n  }\n\n  modifier proxyRight(address delegatedFrom) {\n    require(\n      voteDelegations[delegatedFrom] == msg.sender,\n      'User does not have proxy right'\n    );\n    _;\n  }\n\n  // We reset the iteration back to zero when a user leaves. Means this modifier will no longer protect.\n  // But, its okay because it cannot be exploited. When 0, the user will have zero deposit.\n  // Therefore that modifier will always catch them in that case :)\n  modifier joinedInTime(address givenAddress) {\n    require(\n      iterationJoined[givenAddress] < proposalIteration,\n      'User only eligible to vote next iteration'\n    );\n    _;\n  }\n\n  modifier lockInFulfilled(address givenAddress) {\n    require(\n      iterationJoined[givenAddress] + 2 < proposalIteration,\n      'Benefactor only eligible to receive funds in later iteration'\n    );\n    _;\n  }\n  modifier iterationElapsed() {\n    require(proposalDeadline < now, 'iteration interval not ended');\n    _;\n  }\n\n\n  modifier iterationMostlyElapsed() {\n    require(\n      proposalDeadline.sub(votingInterval.div(7)) < now,\n      'Not yet eligible to redirect interest stream'\n    );\n    _;\n  }\n\n  modifier depositContractOnly() {\n    require(\n      address(depositContract) == msg.sender, // Is this a valid way of getting the address?\n      'function can only be called by deposit contract'\n    );\n    _;\n  }\n\n  ////////////////////////////////////\n  //////// SETUP CONTRACT////////////\n  //// NOTE: Upgradable at the moment\n  function initialize(address depositContractAddress, uint256 _votingInterval)\n    public\n    initializer\n  {\n    depositContract = IPoolDeposits(depositContractAddress);\n    admin = msg.sender;\n    votingInterval = _votingInterval;\n    proposalDeadline = now.add(_votingInterval);\n  }\n\n  ///////////////////////////////////\n  /////// Config functions //////////\n  ///////////////////////////////////\n\n  /// @dev Changes the time iteration  between intervals\n  /// @param newInterval new time interval between interations\n  function changeVotingInterval(uint256 newInterval) public onlyAdmin {\n    votingInterval = newInterval;\n  }\n\n  // change miner reward here\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /////// Deposit & withdraw function for users //////////\n  ////////and proposal holders (benefactors) /////////////\n  ////////////////////////////////////////////////////////\n\n  /// @dev Checks whether user is eligible deposit and sets the proposal iteration joined, to the current iteration\n  /// @param userAddress address of the user wanting to deposit\n  /// @return boolean whether the above executes successfully\n  function noLossDeposit(address userAddress)\n    external\n    depositContractOnly\n    userHasNoProposal(userAddress) // Checks they are not a benefactor\n    returns (bool)\n  {\n    iterationJoined[userAddress] = proposalIteration;\n    return true;\n  }\n\n  /// @dev Checks whether user is eligible to withdraw their deposit and sets the proposal iteration joined to zero\n  /// @param userAddress address of the user wanting to withdraw\n  /// @return boolean whether the above executes successfully\n  function noLossWithdraw(address userAddress)\n    external\n    depositContractOnly\n    noVoteYet(userAddress)\n    userHasNoProposal(userAddress)\n    returns (bool)\n  {\n    iterationJoined[userAddress] = 0;\n    return true;\n  }\n\n  /// @dev Checks whether user is eligible to create a proposal then creates it. Executes a range of logic to add the new propsal (increments proposal ID, sets proposal owner, sets iteration joined, etc...)\n  /// @param proposalHash Hash of the proposal text\n  /// @param benefactorAddress address of benefactor creating proposal\n  /// @return boolean whether the above executes successfully\n  function noLossCreateProposal(\n    string calldata proposalHash,\n    address benefactorAddress\n  ) external depositContractOnly returns (uint256 newProposalId) {\n    proposalId = proposalId.add(1);\n\n    proposalDetails[proposalId] = proposalHash;\n    proposalOwner[proposalId] = benefactorAddress;\n    benefactorsProposal[benefactorAddress] = proposalId;\n    state[proposalId] = ProposalState.Active;\n    iterationJoined[benefactorAddress] = proposalIteration;\n    return proposalId;\n  }\n\n  /// @dev Checks whether user is eligible to withdraw their proposal\n  /// Sets the state of the users proposal to withdrawn\n  /// resets the iteration of user joined back to 0\n  /// @param benefactorAddress address of benefactor withdrawing proposal\n  /// @return boolean whether the above is possible\n  function noLossWithdrawProposal(address benefactorAddress)\n    external\n    depositContractOnly\n    userHasActiveProposal(benefactorAddress)\n    lockInFulfilled(benefactorAddress)\n    returns (bool)\n  {\n    iterationJoined[benefactorAddress] = 0;\n    state[benefactorsProposal[benefactorAddress]] = ProposalState.Withdrawn;\n    return true;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /////// DAO voting functionality  //////////////////////\n  ////////////////////////////////////////////////////////\n\n  /// @dev Allows user to delegate their full voting power to another user\n  /// @param delegatedAddress the address to which you are delegating your voting rights\n  function delegateVoting(address delegatedAddress)\n    external\n    userStaked(msg.sender)\n    userHasNoActiveProposal(msg.sender) //Careful when in cooldown can delegate then ???\n    userHasNoActiveProposal(delegatedAddress)\n  {\n    voteDelegations[msg.sender] = delegatedAddress;\n    emit VoteDelegated(msg.sender, delegatedAddress);\n  }\n\n  /// @dev Allows user to vote for an active proposal. Once voted they cannot withdraw till next iteration.\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\n  function voteDirect(\n    uint256 proposalIdToVoteFor // breaking change -> function name change from vote to voteDirect\n  )\n    external\n    proposalActive(proposalIdToVoteFor)\n    noVoteYet(msg.sender)\n    userStaked(msg.sender)\n    userHasNoActiveProposal(msg.sender)\n    joinedInTime(msg.sender)\n  {\n    _vote(proposalIdToVoteFor, msg.sender);\n    emit VotedDirect(msg.sender, proposalIteration, proposalIdToVoteFor);\n  }\n\n  /// @dev Allows user proxy to vote on behalf of a user.\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\n  /// @param delegatedFrom user they are voting on behalf of\n  function voteProxy(uint256 proposalIdToVoteFor, address delegatedFrom)\n    external\n    proposalActive(proposalIdToVoteFor)\n    proxyRight(delegatedFrom)\n    noVoteYet(delegatedFrom)\n    userStaked(delegatedFrom)\n    userHasNoActiveProposal(delegatedFrom)\n    joinedInTime(delegatedFrom)\n  {\n    _vote(proposalIdToVoteFor, delegatedFrom);\n    emit VotedViaProxy(\n      msg.sender,\n      delegatedFrom,\n      proposalIteration,\n      proposalIdToVoteFor\n    );\n  }\n\n  /// @dev Internal function casting the actual vote from the requested address\n  /// @param proposalIdToVoteFor Id of the proposal they are voting for\n  /// @param voteAddress address the vote is stemming from\n  function _vote(uint256 proposalIdToVoteFor, address voteAddress) internal {\n    usersNominatedProject[proposalIteration][voteAddress] = proposalIdToVoteFor;\n    proposalVotes[proposalIteration][proposalIdToVoteFor] = proposalVotes[proposalIteration][proposalIdToVoteFor]\n      .add(depositContract.depositedDai(voteAddress));\n\n\n      uint256 topProjectVotes\n     = proposalVotes[proposalIteration][topProject[proposalIteration]];\n\n    // Currently, proposal getting to top vote first will win [this is fine]\n    if (\n      proposalVotes[proposalIteration][proposalIdToVoteFor] > topProjectVotes\n    ) {\n      topProject[proposalIteration] = proposalIdToVoteFor;\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /////// Iteration changer / mining function  //////////////////////\n  ///////////////////////////////////////////////////////////////////\n\n  /// @dev Anyone can call this every 2 weeks (more specifically every *iteration interval*) to receive a reward, and increment onto the next iteration of voting\n  function distributeFunds() external iterationElapsed {\n    // On a *whatever we decide basis* the funds are distributed to the winning project\n    // E.g. every 2 weeks, the project with the most votes gets the generated interest.\n    // figure our what happens with the interest from the first proposal iteration\n    // Possibly make first iteration an extended one for our launch (for marketing)\n    // console.log(\n    //   'Iteration no: ',\n    //   proposalIteration,\n    //   'Time that this iteration has ended incremented ',\n    //   proposalDeadline\n    // );\n    if (topProject[proposalIteration] != 0) {\n      // Do some asserts here for safety...\n\n      // Only if last winner is not withdrawn (i.e. still in cooldown) make it active again\n      if (\n        state[topProject[proposalIteration.sub(1)]] == ProposalState.Cooldown\n      ) {\n        state[topProject[proposalIteration.sub(1)]] = ProposalState.Active;\n      }\n      // Only if they haven't withdrawn, put them in cooldown\n      if (state[topProject[proposalIteration]] != ProposalState.Withdrawn) {\n        state[topProject[proposalIteration]] = ProposalState.Cooldown;\n      }\n      address winner = proposalOwner[topProject[proposalIteration]]; // error if no-one voted for in this iteration\n      depositContract.redirectInterestStreamToWinner(winner);\n      emit IterationWinner(\n        proposalIteration,\n        winner,\n        topProject[proposalIteration]\n      );\n    }\n\n    proposalDeadline = now.add(votingInterval);\n    proposalIteration = proposalIteration.add(1);\n    // console.log(\n    //   'Iteration no: ',\n    //   proposalIteration,\n    //   ' Will start now and end earliest at',\n    //   proposalDeadline\n    // );\n\n    // send winning miner a little surprise [NFT]\n    emit IterationChanged(now, msg.sender);\n  }\n\n  // Allows admin to redirect interest stream to themselves for (1/7 of the total time = 15%) fee to continue funding developement\n  function daoCareFunding(address redirectTo)\n    external\n    onlyAdmin\n    iterationMostlyElapsed\n  {\n    depositContract.redirectInterestStreamToWinner(redirectTo);\n  }\n}\n"
    },
    "@nomiclabs/buidler/console.sol": {
      "content": "pragma solidity >= 0.5.0 <0.7.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction log() internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\n\t\tignored;\n\t}\tfunction logInt(int p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t\tignored;\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t\tignored;\n\t}\n\n}\n"
    },
    "contracts/PoolDeposits.sol": {
      "content": "pragma solidity 0.5.15;\n\n//import './interfaces/IERC20.sol';\nimport './interfaces/IAaveLendingPool.sol';\nimport './interfaces/IADai.sol';\nimport './interfaces/INoLossDao.sol';\nimport './interfaces/ILendingPoolAddressesProvider.sol';\nimport '@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol';\nimport '@nomiclabs/buidler/console.sol';\n\n\n/** @title Pooled Deposits Contract*/\ncontract PoolDeposits {\n  using SafeMath for uint256;\n\n  address public admin;\n  uint256 public totalDepositedDai;\n  mapping(address => uint256) public depositedDai;\n\n  uint256 public proposalAmount; // Stake required to submit a proposal\n\n  ///////// DEFI Contrcats ///////////\n  IERC20 public daiContract;\n  IAaveLendingPool public aaveLendingContract;\n  IADai public adaiContract;\n  INoLossDao public noLossDaoContract; // should we be able to change this as admin.\n  ILendingPoolAddressesProvider public provider;\n  address public aaveLendingContractCore;\n\n  //////// EMERGENCY MODULE ONLY ///////\n  uint256 public emergencyVoteAmount;\n  mapping(address => bool) public emergencyVoted;\n  mapping(address => uint256) public timeJoined;\n  bool public isEmergencyState;\n\n  ///////// Events ///////////\n  event DepositAdded(address indexed user, uint256 amount);\n  event ProposalAdded(\n    address indexed benefactor,\n    uint256 indexed proposalId,\n    string proposalHash\n  );\n  event DepositWithdrawn(address indexed user);\n  event ProposalWithdrawn(address indexed benefactor);\n\n  ///////// Emergency Events ///////////\n  event EmergencyStateReached(\n    address indexed user,\n    uint256 timeStamp,\n    uint256 totalDaiInContract,\n    uint256 totalEmergencyVotes\n  );\n  event EmergencyVote(address indexed user, uint256 emergencyVoteAmount);\n  event RemoveEmergencyVote(address indexed user, uint256 emergencyVoteAmount);\n  event EmergencyWithdrawl(address indexed user);\n\n  ///////////////////////////////////////////////////////////////////\n  //////// EMERGENCY MODIFIERS //////////////////////////////////////\n  ///////////////////////////////////////////////////////////////////\n  modifier emergencyEnacted() {\n    require(\n      totalDepositedDai < emergencyVoteAmount.mul(2), //safe 50%\n      '50% of total pool needs to have voted for emergency state'\n    );\n    require(\n      totalDepositedDai > 200000000000000000000000, //200 000 DAI needed in contract\n      '200 000DAI required in pool before emergency state can be declared'\n    );\n    _;\n  }\n  modifier noEmergencyVoteYet() {\n    require(emergencyVoted[msg.sender] == false, 'Already voted for emergency');\n    _;\n  }\n  modifier stableState() {\n    require(isEmergencyState == false, 'State of emergency declared');\n    _;\n  }\n  modifier emergencyState() {\n    require(isEmergencyState == true, 'State of emergency not declared');\n    _;\n  }\n  // Required to be part of the pool for 100 days. Make it costly to borrow and put into state of emergency.\n  modifier eligibleToEmergencyVote() {\n    require(\n      timeJoined[msg.sender].add(8640000) < now,\n      'Need to have joined for 100days to vote an emergency'\n    );\n    _;\n  }\n  ////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////\n  //////// Modifiers /////////////////\n  ////////////////////////////////////\n  modifier noLossDaoContractOnly() {\n    require(\n      address(noLossDaoContract) == msg.sender, // Is this a valid way of getting the address?\n      'function can only be called by no Loss Dao contract'\n    );\n    _;\n  }\n\n  modifier allowanceAvailable(uint256 amount) {\n    require(\n      amount <= daiContract.allowance(msg.sender, address(this)), // checking the pool deposits contract\n      'amount not available'\n    );\n    _;\n  }\n\n  modifier requiredDai(uint256 amount) {\n    require(\n      daiContract.balanceOf(msg.sender) >= amount,\n      'User does not have enough DAI'\n    );\n    _;\n  }\n\n  modifier blankUser() {\n    require(depositedDai[msg.sender] == 0, 'Person is already a user');\n    _;\n  }\n\n  modifier userStaked() {\n    require(depositedDai[msg.sender] > 0, 'User has no stake');\n    _;\n  }\n\n  /***************\n    Contract set-up: Not Upgradaable\n    ***************/\n  constructor(\n    address daiAddress,\n    address aDaiAddress,\n    //address aavePoolAddress,\n    // kovan 0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5\n    // mainnet 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8\n    address lendingPoolAddressProvider,\n    address noLossDaoAddress,\n    uint256 _proposalAmount\n  ) public {\n    daiContract = IERC20(daiAddress);\n    provider = ILendingPoolAddressesProvider(lendingPoolAddressProvider);\n    adaiContract = IADai(aDaiAddress);\n    noLossDaoContract = INoLossDao(noLossDaoAddress);\n    admin = msg.sender;\n    proposalAmount = _proposalAmount; // if we want this configurable put in other contract\n    isEmergencyState = false;\n  }\n\n  /// @dev Internal function completing the actual deposit to Aave and crediting users account\n  /// @param amount amount being deosited into pool\n  function _depositFunds(uint256 amount) internal {\n    aaveLendingContract = IAaveLendingPool(provider.getLendingPool());\n    aaveLendingContractCore = provider.getLendingPoolCore();\n\n    daiContract.transferFrom(msg.sender, address(this), amount);\n    daiContract.approve(aaveLendingContractCore, amount);\n    aaveLendingContract.deposit(address(daiContract), amount, 30);\n\n    timeJoined[msg.sender] = now;\n    depositedDai[msg.sender] = amount;\n    totalDepositedDai = totalDepositedDai.add(amount);\n  }\n\n  /// @dev Internal function completing the actual redemption from Aave and sendinding funds back to user\n  function _withdrawFunds() internal {\n    uint256 amount = depositedDai[msg.sender];\n    _removeEmergencyVote();\n\n    depositedDai[msg.sender] = 0;\n    totalDepositedDai = totalDepositedDai.sub(amount);\n\n    adaiContract.redeem(amount);\n    daiContract.transfer(msg.sender, amount);\n  }\n\n  /// @dev Lets a user join DAOcare through depositing\n  /// @param amount the user wants to deposit into the DAOcare pool\n  function deposit(uint256 amount)\n    external\n    blankUser\n    allowanceAvailable(amount)\n    requiredDai(amount)\n    stableState\n  {\n    _depositFunds(amount);\n    noLossDaoContract.noLossDeposit(msg.sender);\n    emit DepositAdded(msg.sender, amount);\n  }\n\n  /// @dev Lets a user withdraw their original amount sent to DAOcare\n  /// Calls the NoLossDao conrrtact to determine eligibility to withdraw\n  /// Withdraws the proposalAmount (50DAI) if succesful\n  function withdrawDeposit() external userStaked {\n    _withdrawFunds();\n    noLossDaoContract.noLossWithdraw(msg.sender);\n    emit DepositWithdrawn(msg.sender);\n  }\n\n  /// @dev Lets user create proposal\n  /// @param proposalHash hash of the users new proposal\n  function createProposal(string calldata proposalHash)\n    external\n    blankUser\n    allowanceAvailable(proposalAmount)\n    requiredDai(proposalAmount)\n    stableState\n    returns (uint256 newProposalId)\n  {\n    _depositFunds(proposalAmount);\n    uint256 proposalId = noLossDaoContract.noLossCreateProposal(\n      proposalHash,\n      msg.sender\n    );\n    emit ProposalAdded(msg.sender, proposalId, proposalHash);\n    return proposalId;\n  }\n\n  /// @dev Lets user withdraw proposal\n  function withdrawProposal() external {\n    _withdrawFunds();\n    noLossDaoContract.noLossWithdrawProposal(msg.sender);\n    emit ProposalWithdrawn(msg.sender);\n  }\n\n  /// @dev Sets the interest to acrue to winner of the iteration\n  /// @param _winner The address of the proposal winning the iteration\n  function redirectInterestStreamToWinner(address _winner)\n    external\n    noLossDaoContractOnly\n  {\n    adaiContract.redirectInterestStream(_winner);\n  }\n\n  //////////////////////////////////////////////////\n  //////// EMERGENCY MODULE FUNCTIONS  //////////////\n  ///////////////////////////////////////////////////\n\n  /// @dev Declares a state of emergency and enables emergency withdrawls that are not dependant on any external smart contracts\n  function declareStateOfEmergency() external emergencyEnacted {\n    isEmergencyState = true;\n    emit EmergencyStateReached(\n      msg.sender,\n      now,\n      totalDepositedDai,\n      emergencyVoteAmount\n    );\n  }\n\n  /// @dev Immediately lets yoou withdraw your funds in an state of emergency\n  function emergencyWithdraw() external userStaked emergencyState {\n    _withdrawFunds();\n    emit EmergencyWithdrawl(msg.sender);\n  }\n\n  /// @dev lets users vote that the a state of emergency should be decalred\n  /// Requires time lock here to defeat flash loan punks\n  function voteEmergency()\n    external\n    userStaked\n    noEmergencyVoteYet\n    eligibleToEmergencyVote\n  {\n    emergencyVoted[msg.sender] = true;\n    emergencyVoteAmount = emergencyVoteAmount.add(depositedDai[msg.sender]);\n    emit EmergencyVote(msg.sender, depositedDai[msg.sender]);\n  }\n\n  /// @dev Internal function removing a users emergency vote if they leave the pool\n  function _removeEmergencyVote() internal {\n    bool status = emergencyVoted[msg.sender];\n    emergencyVoted[msg.sender] = false;\n    if (status == true) {\n      emergencyVoteAmount = emergencyVoteAmount.sub(depositedDai[msg.sender]);\n      emit RemoveEmergencyVote(msg.sender, depositedDai[msg.sender]);\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}